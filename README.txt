avoid these errors when adjusting procs:

- sp_ScaleItemToIlvl_SimpleGreedy(entry, target_ilvl, apply, scale_auras)
- primary stats, resistances, and (optionally) auras (excluding hit/crit percentages) start from the same shared scale factor so everything shrinks or grows together before rounding
  - hit/crit percentages stay fixed; the remaining stats shift around them so the recomputed item level still hits the requested target
- after resolving aura conflicts, primaries and resistances receive a shared nudge so the recomputed item level hits the request without skewing the aura mix

- automation must never update helper.aura_spell_catalog or dbc.spell_lplus.
  - if a new aura magnitude is needed, create a separate SQL script that INSERTs a fresh row into spell_lplus;
    existing spell_lplus data remains immutable.

22:05:05	CREATE PROCEDURE helper.sp_ScaleItemToIlvl_SimpleGreedy(   IN p_entry INT UNSIGNED,   IN p_target_ilvl INT UNSIGNED,   IN p_apply TINYINT(1),   IN p_scale_auras TINYINT(1)        -- p_apply: 0=dry run, 1=apply changes; p_scale_auras: 0=skip aura scaling, nonzero=scale auras ) BEGIN   /* ===== constants (must match estimator’s slotmods/curves) ===== */   DROP TEMPORARY TABLE IF EXISTS tmp_slotmods_g;   CREATE TEMPORARY TABLE tmp_slotmods_g(inv TINYINT PRIMARY KEY, slotmod DOUBLE) ENGINE=Memory;   INSERT INTO tmp_slotmods_g VALUES     (1,1.00),(5,1.00),(20,1.00),(7,1.00),     (3,1.35),(10,1.35),(6,1.35),(8,1.35),     (12,1.47),     (9,1.85),(2,1.85),(16,1.85),(11,1.85),     (17,1.00),     (13,2.44),(21,2.44),     (14,1.92),(22,1.92),(23,1.92),     (15,3.33),(26,3.33),(25,3.33);    DROP TEMPORARY TABLE IF EXISTS tmp_qcurve_g;   CREATE TEMPORARY TABLE tmp_qcurve_g(quality TINYINT PRIMARY KEY, a DOUBLE, b DOUBLE) ENGINE=Memory;   INSERT INTO tmp_qcurve_g VALUES (2,1.21,-9.8),(3,1.42,-4.2),(4,1.64,11.2);    /* weight of primaries in term-space (same as estimator) */   SET @W_PRIMARY := 230.0;    /* ===== read item basics ===== */   SELECT Quality, InventoryType, CAST(trueItemLevel AS SIGNED)     INTO @q, @inv, @ilvl_cur   FROM lplusworld.item_template   WHERE entry = p_entry;    IF @q NOT IN (2,3,4) THEN     -- unsupported for this simple scaler, exit quietly     LEAVE proc_end;   END IF;    SELECT a,b INTO @a,@b FROM tmp_qcurve_g WHERE quality=@q;   SET @slotmod := IFNULL((SELECT slotmod FROM tmp_slotmods_g WHERE inv=@inv),1.00);    /* ===== compute target “sum” S_tgt from desired ilvl ===== */   SET @isv_tgt       := @a * p_target_ilvl + @b;     -- ItemSlotValue (inverse curve)   SET @itemvalue_tgt := @isv_tgt / @slotmod;   SET @S_tgt         := POW(@itemvalue_tgt * 100.0, 1.5);    /* ===== snapshot all 10 stat slots (types & values) ===== */   SELECT stat_type1,stat_value1, stat_type2,stat_value2, stat_type3,stat_value3,          stat_type4,stat_value4, stat_type5,stat_value5, stat_type6,stat_value6,          stat_type7,stat_value7, stat_type8,stat_value8, stat_type9,stat_value9,          stat_type10,stat_value10   INTO  @st1,@sv1, @st2,@sv2, @st3,@sv3,         @st4,@sv4, @st5,@sv5, @st6,@sv6,         @st7,@sv7, @st8,@sv8, @st9,@sv9,         @st10,@sv10   FROM lplusworld.item_template   WHERE entry = p_entry;    /* ===== group present primaries (3..7) and compute S_cur_p ===== */   DROP TEMPORARY TABLE IF EXISTS tmp_pcur;   CREATE TEMPORARY TABLE tmp_pcur(stat TINYINT PRIMARY KEY, v DOUBLE) ENGINE=Memory;    INSERT INTO tmp_pcur(stat,v)   SELECT s, SUM(vv) FROM (     SELECT @st1 s, @sv1 vv UNION ALL     SELECT @st2, @sv2 UNION ALL     SELECT @st3, @sv3 UNION ALL     SELECT @st4, @sv4 UNION ALL     SELECT @st5, @sv5 UNION ALL     SELECT @st6, @sv6 UNION ALL     SELECT @st7, @sv7 UNION ALL     SELECT @st8, @sv8 UNION ALL     SELECT @st9, @sv9 UNION ALL     SELECT @st10,@sv10   ) z   WHERE s IN (3,4,5,6,7) AND vv IS NOT NULL AND vv > 0   GROUP BY s;    SET @k := (SELECT COUNT(*) FROM tmp_pcur);   IF @k = 0 THEN     -- no primaries: seed with STA slot so we can scale     INSERT INTO tmp_pcur VALUES (7, 0);     SET @k := 1;   END IF;    /* S_cur from current trueItemLevel (reuse estimator’s mapping) */   SET @isv_cur       := @a * @ilvl_cur + @b;   SET @itemvalue_cur := @isv_cur / @slotmod;   SET @S_cur         := POW(@itemvalue_cur * 100.0, 1.5);    /* S_cur_p: term-sum contributed by primaries only */   SELECT IFNULL(SUM(POW(GREATEST(0, v * @W_PRIMARY), 1.5)), 0.0)     INTO @S_cur_p   FROM tmp_pcur;    /* amount primaries need to change to hit S_tgt while holding non-primaries fixed */   SET @S_fixed  := @S_cur - @S_cur_p;                -- everything except primaries   SET @delta_p  := @S_tgt - (@S_fixed + @S_cur_p);   -- change we must allocate to primaries   SET @each_p   := @delta_p / @k;                    -- even share in term-space    /* ===== compute new primary values (invert 1.5 power per stat) ===== */   DROP TEMPORARY TABLE IF EXISTS tmp_pnew;   CREATE TEMPORARY TABLE tmp_pnew(stat TINYINT PRIMARY KEY, newv INT) ENGINE=Memory;    INSERT INTO tmp_pnew(stat,newv)   SELECT stat,          ROUND(           ...	Error Code: 1308. LEAVE with no matching label: proc_end	0.000 sec
22:00:35	CALL helper.sp_TuneTrueItemLevel_ConsumeQueue(10)	Error Code: 1137. Can't reopen table: 'n1'	0.016 sec
